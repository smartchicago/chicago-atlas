- content_for :javascripts do
  = javascript_include_tag "leaflet"
  = javascript_include_tag "leaflet.label"

  :javascript
    $(window).resize(function () {
      var h = $(window).height(),
        offsetTop = 70; // Calculate the top offset

      $('#map').css('height', (h - offsetTop));
    }).resize();


    var geojsonFeature = #{@display_geojson};

    var intervention_locations = #{@intervention_locations};

    var map = L.map('map').setView([41.8781136, -87.66677856445312], 11);

    var cloudmade = L.tileLayer('http://{s}.tile.cloudmade.com/{key}/{styleId}/256/{z}/{x}/{y}.png', {
        attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 CloudMade',
        key: 'BC9A493B41014CAABB98F0471D759707',
        styleId: 22677
    }).addTo(map);


    // control that shows info on hover
    var info = L.control();

    info.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'info');
        this.update();
        return this._div;
    };

    info.update = function (props) {
        this._div.innerHTML = '<h4>Community area</h4>' +  (props ?
            '<b>' + props.name + '</b><br />' + props.condition_title + ': ' + props.condition_value
            : 'Hover over a community area');
    };

    // info.addTo(map);


    // get color depending on condition_title
    function getColor(d) {
        #{choropleth_function(@current_dataset.choropleth_cutoffs_json)}
    }

    function style(feature) {
        return {
            weight: 2,
            opacity: 1,
            color: 'white',
            dashArray: '3',
            fillOpacity: 0.7,
            fillColor: getColor(feature.properties.condition_value)
        };
    }

    function highlightFeature(e) {
        var layer = e.target;

        layer.setStyle({
            weight: 5,
            color: '#666',
            dashArray: '',
            fillOpacity: 0.7
        });

        if (!L.Browser.ie && !L.Browser.opera) {
            layer.bringToFront();
        }

        //info.update(layer.feature.properties);
    }

    var geojson;

    function resetHighlight(e) {
        geojson.resetStyle(e.target);
        //info.update();
    }

    function onEachFeature(feature, layer) {
        layer.on({
            mouseover: highlightFeature,
            mouseout: resetHighlight,
            click: linkToDetail
        });
        
        var props = layer.feature.properties;
        layer.bindLabel( '<h4>' + props.name + '</h4>' + props.condition_title + ': ' + props.condition_value );
    }

    function linkToDetail(e) {
        window.location = '/place/' + e.target.feature.properties.slug;
    }

    geojson = L.geoJson(geojsonFeature, {
        style: style,
        onEachFeature: onEachFeature
    }).addTo(map);

    var clinicIcon = L.icon({
        iconUrl: '/assets/firstaid.png',
        shadowUrl: '/assets/square-shadow.png'
    });

    for (point in intervention_locations) {
        L.marker([intervention_locations[point][2], intervention_locations[point][3]], {icon: clinicIcon}).addTo(map).bindPopup("<b>" + intervention_locations[point][0] + "</b><br />" + intervention_locations[point][1]);
    }


    var legend = L.control({position: 'bottomright'});

    legend.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            grades = #{@current_dataset.choropleth_cutoffs_json},
            labels = [],
            from, to;

        for (var i = 0; i < grades.length; i++) {
            from = grades[i];
            to = grades[i + 1];

            labels.push(
                '<i style="background:' + getColor(from + 1) + '"></i> ' +
                from + (to ? '&ndash;' + to : '+'));
        }

        div.innerHTML = labels.join('<br>');
        return div;
    };

    legend.addTo(map);

.row-fluid
  .span4
    %h4 Year
    %ul.inline
      - (@current_dataset.start_year..@current_dataset.end_year).each do |y|
        %li
          - if y.to_s == params[:year]
            %strong
              = y
          - else
            %a{:href => "/map/#{params[:dataset_id]}/#{y}"} 
              = y

    %hr
    - @categories.each do |c|
      %h4
        = c.name

      %ul
        - Dataset.where(:category_id => c.id).order("name").each do |d|
          %li
            - if d.id.to_s == params[:dataset_id]
              %strong
                = d.name
              - if @intervention_locations.length > 0
                = "(showing #{@intervention_locations.length} clinics)"
            - else
              %a{:href => "/map/#{d.id}/#{params[:year]}"} 
                = d.name

  .span8
    #map